<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bad Roads Map – Safe Routes</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <!-- Leaflet Routing Machine CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css"
  />

  <style>
    html, body { height: 100%; margin: 0; }
    #app { display: flex; height: 100%; }
    #map { flex: 1 1 auto; background: #f0f2f5; }
    .sidebar {
      width: 320px; max-width: 100vw; background: #fff;
      border-left: 1px solid #e0e0e0;
      font: 14px/1.45 system-ui, Arial, sans-serif;
      padding: 12px 14px; overflow: auto;
    }
    .sidebar h2 { margin: 4px 0 8px; font-size: 18px; }
    .sidebar .muted { color: #666; }
    .status {
      margin-top: 10px; padding: 8px 10px; border: 1px solid #ddd;
      background: #fafafa; border-radius: 6px; white-space: pre-line;
    }
    .leaflet-routing-container { display: none; } /* hide LRM panel */
  </style>
</head>
<body>
  <div id="app">
    <div id="map"></div>
    <aside class="sidebar">
      <h2>Safe Route (pothole-aware)</h2>
      <p class="muted">
        Click once to set <b>Start</b>, click again to set <b>End</b>.<br>
        The app prefers routes that stay away from <b>yellow</b> hazards.<br>
        If avoidance isn’t possible, it picks the <b>least affected</b> route.
      </p>
      <div id="status" class="status">Waiting for Start…</div>
      <p class="muted" style="margin-top:10px;">
        Notes:<br>
        – Yellow = medium hazard (pothole).<br>
        – Click a third time to reset and choose a new Start.<br>
        – Your location appears as a blue dot if permitted.
      </p>
    </aside>
  </div>

  <!-- Libraries -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

  <script>
    // ---------- Map ----------
    const map = L.map("map").setView([41.058, 28.919], 14);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors'
    }).addTo(map);

    const ROUTE_COLOR = "#64b5f6";     // light blue route
    const LOC_DOT_COLOR = "#1976d2";   // blue location dot

    // ---------- Sidebar status ----------
    const statusEl = document.getElementById("status");
    const setStatus = (t) => statusEl.textContent = t;

    // ---------- Your location: blue circle dot ----------
    let userLocDot = null;
    map.locate({ setView: false, maxZoom: 16 });
    map.on("locationfound", (e) => {
      if (userLocDot) map.removeLayer(userLocDot);
      userLocDot = L.circleMarker(e.latlng, {
        radius: 6, color: LOC_DOT_COLOR, weight: 2,
        fillColor: LOC_DOT_COLOR, fillOpacity: 1
      }).addTo(map).bindPopup("Your location");
    });

    // ---------- Hazard markers (green/yellow/red) ----------
    const shadow = "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png";
    const colorIcon = (color) => L.icon({
      iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color}.png`,
      shadowUrl: shadow, iconSize: [25,41], iconAnchor: [12,41],
      popupAnchor: [1,-34], shadowSize: [41,41]
    });
    const icons = { low: colorIcon("green"), medium: colorIcon("yellow"), high: colorIcon("red") };

    let potholes = [];
    fetch("./data/points.json")
      .then(r => { if (!r.ok) throw new Error("points.json HTTP " + r.status); return r.json(); })
      .then(points => {
        potholes = Array.isArray(points) ? points : [];
        const bounds = L.latLngBounds();
        potholes.forEach(p => {
          const icon = icons[(p.danger || "medium").toLowerCase()] || icons.medium;
          const latlng = [p.lat, p.lng];
          L.marker(latlng, { icon }).bindPopup(`Pothole<br>${p.desc || ""}`).addTo(map);
          bounds.extend(latlng);
        });
        if (bounds.isValid()) map.fitBounds(bounds, { padding: [30, 30] });
      })
      .catch(err => setStatus("Data load warning: " + err.message));

    // ---------- Routing (OSRM) ----------
    let router = null;
    try {
      if (L.Routing && L.Routing.osrmv1) {
        router = L.Routing.osrmv1({
          serviceUrl: "https://router.project-osrm.org/route/v1",
          profile: "driving",
          timeout: 30000,
          urlParameters: { alternatives: true, overview: "full", steps: false, geometries: "geojson" }
        });
      }
    } catch (e) { setStatus("Routing init failed."); }

    // Prefer away from yellow hazards — soft preference (no blocking)
    const PREFER_LEVELS = ["medium"]; // add "high" to also weight red
    const PROX_RADIUS = 40;           // internal scoring radius (no UI messaging)

    function hazardHits(route) {
      // count how many *distinct hazards* lie close to the route
      let hits = 0;
      for (const p of potholes) {
        if (!PREFER_LEVELS.includes((p.danger || "medium").toLowerCase())) continue;
        const target = [p.lat, p.lng];
        // quick proximity test along the route
        for (const c of route.coordinates) {
          if (map.distance(c, target) < PROX_RADIUS) { hits++; break; }
        }
      }
      return hits;
    }

    // Score routes: fewer hazard hits first, then shorter distance
    function routeScore(route) {
      const h = hazardHits(route);
      const d = route.summary?.totalDistance || 0;
      return h * 1e9 + d; // hazards dominate, distance breaks ties
    }

    // ---------- Click-to-route ----------
    let startMarker = null, endMarker = null, routeLine = null;

    function clearRoute() {
      if (startMarker) map.removeLayer(startMarker);
      if (endMarker)   map.removeLayer(endMarker);
      if (routeLine)   map.removeLayer(routeLine);
      startMarker = endMarker = routeLine = null;
    }
    function setStart(latlng) { if (startMarker) map.removeLayer(startMarker);
      startMarker = L.marker(latlng).addTo(map).bindPopup("Start").openPopup();
      setStatus("Start set. Click again to set End.");
    }
    function setEnd(latlng) { if (endMarker) map.removeLayer(endMarker);
      endMarker = L.marker(latlng).addTo(map).bindPopup("End").openPopup();
      setStatus("End set. Finding best route…");
    }

    function computeRoute() {
      if (!router) { setStatus("Routing unavailable. Check connection or ad-blocker."); return; }
      if (!startMarker || !endMarker) return;

      const wps = [ L.Routing.waypoint(startMarker.getLatLng()), L.Routing.waypoint(endMarker.getLatLng()) ];
      router.route(wps, (err, routes) => {
        if (err || !routes || !routes.length) {
          setStatus("No route found. Try different points.");
          if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
          return;
        }
        // Always choose *some* route; prefer fewer hazard hits
        routes.sort((a, b) => routeScore(a) - routeScore(b));
        const best = routes[0];

        if (routeLine) map.removeLayer(routeLine);
        routeLine = L.polyline(best.coordinates, { color: ROUTE_COLOR, weight: 6, opacity: 0.9 }).addTo(map);
        map.fitBounds(routeLine.getBounds(), { padding: [40, 40] });

        const km = ((best.summary?.totalDistance || 0) / 1000).toFixed(2);
        const mins = Math.round((best.summary?.totalTime || 0) / 60);
        const hits = hazardHits(best);
        setStatus(`Route ready. Distance: ${km} km, Time: ~${mins} min. Yellow zones encountered: ${hits}.`);
      });
    }

    // 1st click = Start, 2nd = End (compute), 3rd = reset & new Start
    map.on("click", (e) => {
      if (!startMarker) {
        setStart(e.latlng);
      } else if (!endMarker) {
        setEnd(e.latlng);
        computeRoute();
      } else {
        clearRoute();
        setStart(e.latlng);
      }
    });

    map.getContainer().style.cursor = "crosshair";
  </script>
</body>
</html>

