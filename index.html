<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bad Roads Map – Safe Routes</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <!-- Leaflet Routing Machine (used programmatically) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css"
  />

  <style>
    html, body { height: 100%; margin: 0; }
    #app { display: flex; height: 100%; }
    #map { flex: 1 1 auto; background: #f0f2f5; }
    .sidebar {
      width: 320px; max-width: 100vw; background: #fff;
      border-left: 1px solid #e0e0e0;
      font: 14px/1.45 system-ui, Arial, sans-serif;
      padding: 12px 14px; overflow: auto;
    }
    .sidebar h2 { margin: 4px 0 8px; font-size: 18px; }
    .sidebar .muted { color: #666; }
    .status {
      margin-top: 10px; padding: 8px 10px; border: 1px solid #ddd;
      background: #fafafa; border-radius: 6px; white-space: pre-line;
    }
    .leaflet-routing-container { display: none; } /* hide LRM panel */
  </style>
</head>
<body>
  <div id="app">
    <div id="map"></div>
    <aside class="sidebar">
      <h2>Safe Route (pothole-aware)</h2>
      <p class="muted">
        Click the map to set <b>Start</b>, then click again to set <b>End</b>.<br>
        The app prefers routes that avoid <b>yellow</b> hazards.<br>
        If all routes touch hazards, it picks the <b>least affected</b> one.
      </p>
      <div id="status" class="status">Waiting for Start…</div>
      <p class="muted" style="margin-top:10px;">
        Notes:<br>
        – Yellow = medium hazard (pothole).<br>
        – Click a third time to reset and choose a new Start.<br>
        – Your location is shown as a blue dot when permitted.
      </p>
    </aside>
  </div>

  <!-- Libraries -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

  <script>
    // ---------- Map ----------
    const map = L.map("map").setView([41.058, 28.919], 14);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors'
    }).addTo(map);

    const ROUTE_COLOR = "#64b5f6"; // light blue for routes
    const LOC_DOT_COLOR = "#1976d2"; // blue for user location dot

    // ---------- Sidebar status helper ----------
    const statusEl = document.getElementById("status");
    function setStatus(text) { statusEl.textContent = text; }

    // ---------- Your location as a blue circle dot ----------
    let userLocDot = null;
    map.locate({ setView: false, maxZoom: 16 });
    map.on("locationfound", (e) => {
      if (userLocDot) map.removeLayer(userLocDot);
      userLocDot = L.circleMarker(e.latlng, {
        radius: 6,
        color: LOC_DOT_COLOR,
        weight: 2,
        fillColor: LOC_DOT_COLOR,
        fillOpacity: 1
      }).addTo(map).bindPopup("Your location");
    });
    map.on("locationerror", () => { /* ignore; manual start/end still works */ });

    // ---------- Hazard markers (green/yellow/red) ----------
    const shadow = "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png";
    function colorIcon(color) {
      return L.icon({
        iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color}.png`,
        shadowUrl: shadow,
        iconSize: [25, 41], iconAnchor: [12, 41],
        popupAnchor: [1, -34], shadowSize: [41, 41]
      });
    }
    const icons = { low: colorIcon("green"), medium: colorIcon("yellow"), high: colorIcon("red") };

    // ---------- Load pothole data ----------
    let potholes = [];
    fetch("./data/points.json")
      .then(r => {
        if (!r.ok) throw new Error("points.json HTTP " + r.status);
        return r.json();
      })
      .then(points => {
        potholes = Array.isArray(points) ? points : [];
        const bounds = L.latLngBounds();
        potholes.forEach(p => {
          const level = (p.danger || "medium").toLowerCase();
          const icon = icons[level] || icons.medium;
          const latlng = [p.lat, p.lng];
          L.marker(latlng, { icon }).bindPopup(`Pothole<br>${p.desc || ""}`).addTo(map);
          bounds.extend(latlng);
        });
        if (bounds.isValid()) map.fitBounds(bounds, { padding: [30, 30] });
      })
      .catch(err => {
        console.warn("Could not load data/points.json:", err);
        setStatus("Data could not be loaded. Map is still usable.");
      });

    // ---------- Routing (OSRM via LRM, programmatic) ----------
    let router = null;
    try {
      if (L.Routing && L.Routing.osrmv1) {
        router = L.Routing.osrmv1({
          serviceUrl: "https://router.project-osrm.org/route/v1",
          profile: "driving",
          timeout: 30000,
          urlParameters: {
            alternatives: true,     // ask OSRM for alternatives
            overview: "full",
            steps: false,
            geometries: "geojson"
          }
        });
      }
    } catch (e) {
      console.warn("Routing init failed:", e);
    }

    // Preference settings: avoid yellow when possible
    const AVOID_LEVELS = ["medium"]; // add "high" to also weight red strongly
    const AVOID_RADIUS_M = 50;

    function hazardHitsOnRoute(route) {
      let hits = 0;
      for (const p of potholes) {
        if (!AVOID_LEVELS.includes((p.danger || "medium").toLowerCase())) continue;
        // quick scan: if any coordinate gets within radius to this hazard, count a hit
        for (const c of route.coordinates) {
          if (map.distance(c, [p.lat, p.lng]) < AVOID_RADIUS_M) { hits++; break; }
        }
      }
      return hits;
    }

    // Score: prioritize fewer hazard hits; break ties with distance
    function routeScore(route) {
      const hits = hazardHitsOnRoute(route);
      const dist = route.summary?.totalDistance || 0;
      // large weight on hazards so we prefer safety even if longer
      return hits * 1e9 + dist; // 1e9 >> typical distances, ensures hits dominate
    }

    // ---------- Click-to-route flow ----------
    let startMarker = null, endMarker = null, routeLine = null;

    function clearRoute() {
      if (startMarker) map.removeLayer(startMarker);
      if (endMarker)   map.removeLayer(endMarker);
      if (routeLine)   map.removeLayer(routeLine);
      startMarker = endMarker = routeLine = null;
    }

    function setStart(latlng) {
      if (startMarker) map.removeLayer(startMarker);
      startMarker = L.marker(latlng).addTo(map).bindPopup("Start").openPopup();
      setStatus("Start set. Click the map again to set End.");
    }

    function setEnd(latlng) {
      if (endMarker) map.removeLayer(endMarker);
      endMarker = L.marker(latlng).addTo(map).bindPopup("End").openPopup();
      setStatus("End set. Searching for a route that avoids yellow hazards when possible…");
    }

    function computeAndDrawBestRoute() {
      if (!router) { setStatus("Routing engine unavailable. Check connection or ad-blocker."); return; }
      if (!startMarker || !endMarker) return;

      const wps = [
        L.Routing.waypoint(startMarker.getLatLng()),
        L.Routing.waypoint(endMarker.getLatLng())
      ];

      router.route(wps, (err, routes) => {
        if (err || !routes || !routes.length) {
          setStatus("No route found. Try different points.");
          if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
          return;
        }

        // Always pick a route:
        // 1) prefer routes with zero hazard hits
        // 2) otherwise pick route with fewest hits
        // 3) break ties with shortest distance
        routes.sort((a, b) => routeScore(a) - routeScore(b));
        const best = routes[0];
        const hits = hazardHitsOnRoute(best);

        if (routeLine) map.removeLayer(routeLine);
        routeLine = L.polyline(best.coordinates, {
          color: ROUTE_COLOR, weight: 6, opacity: 0.9
        }).addTo(map);
        map.fitBounds(routeLine.getBounds(), { padding: [40, 40] });

        const km = ((best.summary?.totalDistance || 0) / 1000).toFixed(2);
        const mins = Math.round((best.summary?.totalTime || 0) / 60);
        if (hits === 0) {
          setStatus(`Safe route found. Distance: ${km} km, Time: ~${mins} min. No yellow hazards within ${AVOID_RADIUS_M} m.`);
        } else {
          setStatus(`Best available route. Distance: ${km} km, Time: ~${mins} min. Unavoidable yellow hazard zones encountered: ${hits}.`);
        }
      });
    }

    // Clicks: 1 = Start, 2 = End (compute), 3 = reset to new Start
    map.on("click", (e) => {
      if (!startMarker) {
        setStart(e.latlng);
      } else if (!endMarker) {
        setEnd(e.latlng);
        computeAndDrawBestRoute();
      } else {
        clearRoute();
        setStart(e.latlng);
      }
    });

    map.getContainer().style.cursor = "crosshair";
  </script>
</body>
</html>
